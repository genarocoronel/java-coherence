///////////////////////////////////////////////////////////////////////////////
    Copyright (c) 2000, 2020, Oracle and/or its affiliates.

    Licensed under the Universal Permissive License v 1.0 as shown at
    http://oss.oracle.com/licenses/upl.
///////////////////////////////////////////////////////////////////////////////
= Coherence CDI

== Coherence CDI

Coherence CDI provides support for http://cdi-spec.org/[CDI] (Contexts and Dependency  Injection) within Coherence cluster members.

It allows you both to inject Coherence-managed resources, such as `NamedMap`, `NamedCache` and `Scope`  instances into CDI managed beans, to inject CDI beans into Coherence-managed resources,  such as event interceptors and cache stores, and to handle Coherence server-side events using CDI observer methods.

In addition, Coherence CDI provides support for automatic injection of transient objects upon deserialization.
This allows you to inject CDI managed beans such as services and repositories (to use DDD nomenclature) into transient objects, such as entry processor and even data class instances, greatly simplifying implementation of true Domain Driven  applications.

== Usage

In order to use Coherence CDI, you need to declare it as a dependency in your `pom.xml`:

[source,xml]
----
    <dependency>
        <groupId>com.oracle.coherence.ce</groupId>
        <artifactId>coherence-cdi</artifactId>
        <version>${coherence.version}</version>
    </dependency>
----

Once the necessary dependency is in place, you can start using CDI to inject Coherence objects into managed CDI beans, and vice versa, as the following sections describe.

* <<inject-coherence-objects,Injecting Coherence Objects into CDI Beans>>
 ** <<inject-namedmap,Injecting `NamedCache` and related objects>>
  *** <<inject-views,Injecting `NamedCache` or `NamedMap` Views>>
 ** <<inject-namedtopic,Injecting `NamedTopic` and related objects>>
 ** <<other-injection-points,Other Supported Injection Points>>
  *** <<inject-cluster,`Cluster` and `OperationalContext` Injection>>
  *** <<inject-ccf,`ConfigurableCacheFactory` and `Scope` Injection>>
  *** <<inject-serializer,`Serializer` Injection>>
* <<inject-into-coherence,Injecting CDI Beans into Coherence-managed Objects>>
 ** <<cdi-events,Using CDI Observers to Handle Coherence Server-Side Events>>
  *** <<cdi-event-types,Observer specific event types>>
  *** <<cdi-events-filter,Filter the events to be observed>>
  *** <<cdi-events-transform,Transform the events to be observed>>
  *** <<cdi-events-scopes,Observe events for maps and caches in specific scopes or services>>
  *** <<cdi-events-async,Using Asynchronous Observers>>
* <<inject-transient,Injecting CDI Beans into Transient Objects>>
 ** <<transient-injectable,Making transient classes `Injectable`>>
* <<custom-filters,Custom Filter Binding Annotations>>
* <<custom-extractor,Custom Extractor Binding Annotations>>
* <<custom-transformer,Custom MapEventTransformer Binding Annotations>>

[#inject-coherence-objects]
=== Injecting Coherence Objects into CDI Beans

CDI, and dependency injection in general, make it easy for application classes to declare the dependencies they need and let the runtime provide them when necessary.
This makes the applications easier to develop, test and reason about, and the code significantly cleaner.

Coherence CDI allows you to do the same for Coherence objects, such as `Cluster`, `Session`, `NamedMap`,`NamedCache`, `ContinuousQueryCache`, `ConfigurableCacheFactory`, etc.

[#inject-namedmap]
==== Injecting `NamedMap`, `NamedCache` and related objects

In order to inject an instance of a `NamedMap` into your CDI bean, you simply need to define an injection point for it:

[source,java]
----
@Inject
private NamedMap<Long, Person> people;
----

In the example above we've assumed that the map name you want to inject is the same as the name of the field you are injecting into, `people`.
If that's not the case, you can use `@Name` qualifier to specify the name of the map you want to obtain explicitly:

[source,java]
----
@Inject
@Name("people")
private NamedMap<Long, Person> m_people;
----

This is also what you have to do if you are using constructor injection or setter injection:

[source,java]
----
@Inject
public MyClass(@Name("people") NamedMap<Long, Person> people) {
    ...
}

@Inject
public void setPeople(@Name("people") NamedMap<Long, Person> people) {
    ...
}
----

All the examples above assume that you want to use the default scope, which is often, but not always the case.
For example, you may have an Extend client that connects  to multiple Coherence clusters, in which case you would have
multiple scopes.

In this case you would use `@Scope` qualifier to specify the scope name, or the URI of the  configuration file to use:

[source,java]
----
@Inject
@Scope("products-cluster.xml")
private NamedCache<Long, Product> products;

@Inject
@Scope("customers-cluster.xml")
private NamedCache<Long, Customer> customers;
----

You can replace `NamedMap` or `NamedCache` in any of the examples above with `AsyncNamedCache` and `AsyncNamedCache`
respectively, in order to inject  asynchronous variant of those APIs:

[source,java]
----
@Inject
private AsyncNamedMap<Long, Person> people;

@Inject
@Scope("products-cluster.xml")
private AsyncNamedCache<Long, Person> Product;
----

[#inject-views]
===== Inject Views
You can also inject *views*, by simply adding `View` qualifier to either `NamedMap` or `NamedCache`:

[source,java]
----
@Inject
@View
private NamedMap<Long, Person> people;

@Inject
@View
private NamedCache<Long, Product> products;
----

The examples above are equivalent, and both will bring *all* the data from the backing map into a local view, as they
will use `AlwaysFilter` when constructing a view.
If you want to limit the data in the view to a subset, you can implement a <<custom-filters,Custom FilterBinding>>
(recommended), or use a built-in `@WhereFilter` for convenience, which allows you to specify a filter using CohQL:

[source,java]
----
@Inject
@View
@WhereFilter("gender = 'MALE'")
@Name("people")
private NamedMap<Long, Person> men;

@Inject
@View
@WhereFilter("gender = 'FEMALE'")
@Name("people")
private NamedMap<Long, Person> women;
----

The  *views* also support transformation of the entry values on the server, in order to reduce both the amount of data stored locally, and the amount of data transferred over the network.
For example, you may have a complex `Person` objects in the backing map, but only need their names in order to populate a drop down on the client UI.

In that case, you can implement a custom <<custom-extractor,ExtractorBinding>> (recommended), or use a built-in
`@PropertyExtractor` for convenience:

[source,java]
----
@Inject
@View
@PropertyExtractor("fullName")
@Name("people")
private NamedMap<Long, String> names;
----

Note that the value type in the example above has changed from `Person` to `String`, due to server-side transformation caused by the specified `@PropertyExtractor`.

[#inject-namedtopic]
==== Injecting `NamedTopic` and related objects

In order to inject an instance of a `NamedTopic` into your CDI bean, you simply need to define an injection point for it:

[source,java]
----
@Inject
private NamedTopic<Order> orders;
----

In the example above we've assumed that the topic name you want to inject is the same as the name of the field you are injecting into, in this case ``orders``.
If that's not the case, you  can use `@Name` qualifier to specify the name of the topic you want to obtain explicitly:

[source,java]
----
@Inject
@Name("orders")
private NamedTopic<Order> m_orders;
----

This is also what you have to do if you are using constructor or setter injection instead:

[source,java]
----
@Inject
public MyClass(@Name("orders") NamedTopic<Order> orders) {
    ...
}

@Inject
public void setOrdersTopic(@Name("orders") NamedTopic<Order> orders) {
    ...
}
----

All of the examples above assume that you want to use the default scope, which is often, but not always the case.
For example, you may have an Extend client that connects to multiple Coherence clusters, in which case you would have multiple scopes.

In this case you would use `@Scope` qualifier to specify the scope name or the URI of the  configuration file to use:

[source,java]
----
@Inject
@Scope("payments-cluster.xml")
private NamedTopic<PaymentRequest> payments;

@Inject
@Scope("shipments-cluster.xml")
private NamedTopic<ShippingRequest> shipments;
----

The examples above allow you to inject a `NamedTopic` instance into your CDI bean, but it is often simpler and more convenient to inject `Publisher` or `Subscriber` for a given topic instead.

This can be easily accomplished by replacing `NamedTopic<T>` in any of the examples above with either `Publisher<T>`:

[source,java]
----
@Inject
private Publisher<Order> orders;

@Inject
@Name("orders")
private Publisher<Order> m_orders;

@Inject
@Scope("payments-cluster.xml")
private Publisher<PaymentRequest> payments;
----

or `Subscriber<T>`:

[source,java]
----
@Inject
private Subscriber<Order> orders;

@Inject
@Name("orders")
private Subscriber<Order> m_orders;

@Inject
@Scope("payments-cluster.xml")
private Subscriber<PaymentRequest> payments;
----

Topic metadata, such as topic name (based on either injection point name or the explicit name from `@Name` annotation), scope and message type, will be used under the hood to retrieve the `NamedTopic`, and to obtain `Publisher` or `Subscriber` from it.

Additionally, if you want to place your ``Subscriber``s into a subscriber group (effectively turning a topic into a queue), you can easily accomplish that by adding `@SubscriberGroup` qualifier to the injection point:

[source,java]
----
@Inject
@SubscriberGroup("orders-queue")
private Subscriber<Order> orders;
----

[#other-injection-points]
==== Other Supported Injection Points

While the injection of a `NamedMap`, `NamedCache`, `NamedTopic`, and related instances, as shown above,  is probably the single most used feature of Coherence CDI, it is certainly not the only one.
The following sections describe other Coherence artifacts that can be injected using Coherence CDI.

[#inject-cluster]
===== `Cluster` and `OperationalContext` Injection

If you need an instance of a `Cluster` interface somewhere in your application, you can easily obtain it via injection:

[source,java]
----
@Inject
private Cluster cluster;
----

You can do the same if you need an instance of an `OperationalContext`:

[source,java]
----
@Inject
private OperationalContext ctx;
----

[#inject-ccf]
===== `ConfigurableCacheFactory` and `Session` Injection

On rare occasions when you need to use either of these directly, Coherence CDI makes it trivial to do so.

To obtain an instance of a default `ConfigurableCacheFactory` or `Session`, all you need to do is inject them into the  class that needs to use them:

[source,java]
----
@Inject
private ConfigurableCacheFactory ccf;

@Inject
private Session session;
----

If you need a specific `ConfigurableCacheFactory` or `Session` you can simply qualify them using `@Scope` qualifier and specifying the scope name or the URI of the configuration file to use:

[source,java]
----
@Inject
@Scope("my-cache-config.xml")
private ConfigurableCacheFactory ccf;

@Inject
@Scope("my-cache-config.xml")
private ConfigurableCacheFactory session;
----

[#inject-serializer]
===== `Serializer` Injection

While in most cases you won't have to deal with serializers directly, Coherence CDI makes it simple to obtain named serializers (and to register new ones) when you need.

To get a default `Serializer` for the current context class loader, you can simply inject it:

[source,java]
----
@Inject
private Serializer defaultSerializer;
----

However, it may be more useful to inject one of the named serializers defined in the operational configuration, which can be easily accomplished using `@Name` qualifier:

[source,java]
----
@Inject
@Name("java")
private Serializer javaSerializer;

@Inject
@Name("pof")
private Serializer pofSerializer;
----

In addition to the serializers defined in the operational config, the example above will also perform `BeanManager` lookup for a named bean that implements `Serializer` interface.

That means that if you implemented a custom `Serializer` bean, such as:

[source,java]
----
@Named("json")
@ApplicationScoped
public class JsonSerializer implements Serializer {
    ...
}
----

it would be automatically discovered and registered by the CDI, and you would then be able to inject it just as easily as the named serializers defined in the operational config:

[source,java]
----
@Inject
@Name("json")
private Serializer jsonSerializer;
----

[#inject-into-coherence]
=== Injecting CDI Beans into Coherence-managed Objects

Coherence has a number of server-side extension points, which allow users to customize application  behavior in different ways, typically by configuring their extensions within various sections of the  cache configuration file.
For example, the users can implement event interceptors and cache stores,  in order to handle server-side events and integrate with the external data stores and other services.

Coherence CDI provides a way to inject named CDI beans into these extension points using custom  configuration namespace handler.

[source,xml]
----
<cache-config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://xmlns.oracle.com/coherence/coherence-cache-config"
        xmlns:cdi="class://com.oracle.coherence.cdi.CdiNamespaceHandler"
        xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd">
----

Once you've declared the handler for the `cdi` namespace above, you can specify `<cdi:bean>` element in any place where you would normally use `<class-name>` or `<class-factory-name>` elements:

[source,xml]
----
<?xml version="1.0"?>

<cache-config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://xmlns.oracle.com/coherence/coherence-cache-config"
        xmlns:cdi="class://com.oracle.coherence.cdi.CdiNamespaceHandler"
        xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd">

    <interceptors>
        <interceptor>
            <instance>
                <cdi:bean>registrationListener</cdi:bean>
            </instance>
        </interceptor>
        <interceptor>
            <instance>
                <cdi:bean>activationListener</cdi:bean>
            </instance>
        </interceptor>
    </interceptors>

    <caching-scheme-mapping>
        <cache-mapping>
            <cache-name>*</cache-name>
            <scheme-name>distributed-scheme</scheme-name>
            <interceptors>
                <interceptor>
                    <instance>
                        <cdi:bean>cacheListener</cdi:bean>
                    </instance>
                </interceptor>
            </interceptors>
        </cache-mapping>
    </caching-scheme-mapping>

    <caching-schemes>
        <distributed-scheme>
            <scheme-name>distributed-scheme</scheme-name>
            <service-name>PartitionedCache</service-name>
            <local-storage system-property="coherence.distributed.localstorage">true</local-storage>
            <partition-listener>
                <cdi:bean>partitionListener</cdi:bean>
            </partition-listener>
            <member-listener>
                <cdi:bean>memberListener</cdi:bean>
            </member-listener>
            <backing-map-scheme>
                <local-scheme/>
            </backing-map-scheme>
            <autostart>true</autostart>
            <interceptors>
                <interceptor>
                    <instance>
                        <cdi:bean>storageListener</cdi:bean>
                    </instance>
                </interceptor>
            </interceptors>
        </distributed-scheme>
    </caching-schemes>
</cache-config>
----

Note that you can only inject _named_ CDI beans (beans with an explicit `@Named` annotations) via  `<cdi:bean>` element.
For example, the `cacheListener` interceptor bean used above would look similar to this:

[source,java]
----
@ApplicationScoped
@Named("cacheListener")
@EntryEvents(INSERTING)
public class MyCacheListener
        implements EventInterceptor<EntryEvent<Long, String>> {
    @Override
    public void onEvent(EntryEvent<Long, String> e) {
        // handle INSERTING event
    }
}
----

Also keep in mind that only `@ApplicationScoped` beans can be injected, which implies that they  may be shared.
For example, because we've used wildcard `*` as a cache name within the cache mapping in the example above, the same instance of `cacheListener` will receive events from multiple caches.

This is typically fine, as the event itself provides the details about the context that raised it, including cache name and the service it was raised from, but it does imply that any shared state that you may have within your listener class shouldn't be context-specific and it must be safe for concurrent access from multiple threads.
If you can't guarantee the latter, you may want to declare the `onEvent` method as `synchronized`, to ensure only one thread at a time can access any shared state you may have.

[#cdi-events]
==== Using CDI Observers to Handle Coherence Server-Side Events

While the above examples show that you can implement any Coherence `EventInterceptor` as a CDI bean and register it using `<cdi:bean>` element within the cache configuration file, Coherence CDI  also provides a much simpler way to accomplish the same goal using standard CDI Events and Observers.

For example, to observe events raised by a `NamedMap` with the name `people`, with keys of type `Long` and values of type
`Person`, you would define a CDI observer such as this one:

[source,java]
----
private void onMapChange(@Observes @MapName("people") EntryEvent<Long, Person> event) {
    // handle all events raised by the 'people' map/cache
}
----

[#cdi-event-types]
===== Observe Specific Event Types

The observer method above will receive all events for the `people` map, but you can also control the types of events
received using event qualifiers:

[source,java]
----
private void onUpdate(@Observes @Updated @MapName("people") EntryEvent<Long, Person> event) {
    // handle UPDATED events raised by the 'people' map/cache
}

private void onChange(@Observes @Inserted @Updated @Removed @MapName("people") EntryEvent<?, ?> event) {
    // handle INSERTED, UPDATED and REMOVED events raised by the 'people' map/cache
}
----

[#cdi-events-filter]
===== Filter Observed Events

The events observed can be restricted further by using a Coherence `Filter`.
If a filter has been specified, the events will be filtered on the server and will never be sent to the client.
The filter that will be used is specified using a qualifier annotation that is itself annotated with `@FilterBinding`.

You can implement a <<custom-filters,Custom FilterBinding>> (recommended), or use a built-in `@WhereFilter` for
convenience, which allows you to specify a filter using CohQL.

For example to receive all event types in the `people` map, but only for `People` with a `lastName` property value of
`Smith`, the built-in `@WhereFilter` annotation can be used:

[source,java]
----
@WhereFilter("lastName = 'Smith'")
private void onMapChange(@Observes @MapName("people") EntryEvent<Long, Person> event) {
    // handle all events raised by the 'people' map/cache
}
----


[#cdi-events-transform]
===== Transform Observed Events

When an event observer does not want to receive the full cache or map value in an event, the event can be transformed
into a different value to be observed. This is achieved using a `MapEventTransformer` that is applied to the observer
method using either an `ExtractorBinding` annotation or a `MapEventTransformerBinding` annotation.
Transformation of events happens on the server so can make observer's more efficient as they do not need to receive
the original event with the full old and new values.

*Transforming Events Using ExtractorBinding Annotations*

An `ExtractorBinding` annotation is an annotation that represents a Coherence `ValueExtractor`.
When an observer method has been annotated with an `ExtractorBinding` annotation the resulting `ValueExtractor` is
applied to the event's values and a new event will be returned to the observer containing just the extracted
properties.

For example, an event observer that is observing events from a map named `people`, but only requires the last name,
the built in `@PropertyExtractor` annotation can be used.

[source,java]
----
@PropertyExtractor("lastName")
private void onMapChange(@Observes @MapName("people") EntryEvent<Long, String> event) {
    // handle all events raised by the 'people' map/cache
}
----

Unlike the previous examples above the received events of type `EntryEvent<Long, Person>` this method will receive
events of type `EntryEvent<Long, String>` because the property extractor will be applied to the `Person`
values in the original event to extract just the `lastName` proeprty, creating a new event with `String` values.

There are a number of built in `ExtractorBinding` annotations and it is also possible to create custom
`ExtractorBinding` annotation - see the <<custom-extractor,Custom ExtractorBinding Annotations>> section below.

*Transforming Events Using MapEventTransformerBinding Annotations*

If more complex event transformations are required that just extracitng properties from event values, a custom
`MapEventTransformerBinding` can be created that will produce a custom `MapEventTransformer` instance that will be
applied to the observer's events.
See the <<custom-transformer,Custom MapEventTransformerBinding Annotations>> section below for details on how to create
`MapEventTransformerBinding` annotations.



[#cdi-events-scopes]
===== Observe Events for Maps and Caches in Specific Services and Scopes

In addition, to the `@MapName` qualifier, you can also use `@ServiceName` and `@ScopeName` qualifiers as a way to limit
the events received.

The examples above show only how to handle ``EntryEvent``s, but the same applies to all other server-side event types:

[source,java]
----
private void onActivated(@Observes @Activated LifecycleEvent event) {
    // handle cache factory activation
}

private void onCreatedPeople(@Observes @Created @MapName("people") CacheLifecycleEvent event) {
    // handle creation of the 'people' map/cache
}

private void onExecuted(@Observes @Executed @MapName("people") @Processor(Uppercase.class) EntryProcessorEvent event) {
    // intercept 'Uppercase` entry processor execution against 'people' map/cache
}
----

[#cdi-events-async]
===== Using Asynchronous Observers

All the examples above used synchronous observers by specifying `@Observes` qualifier for each observer method.
However, Coherence CDI fully supports asynchronous CDI observers as well.
All you need to do is replace `@Observes` with `@ObservesAsync` in any of the examples above.

[source,java]
----
private void onActivated(@ObservesAsync @Activated LifecycleEvent event) {
    // handle cache factory activation
}

private void onCreatedPeople(@ObservesAsync @Created @MapName("people") CacheLifecycleEvent event) {
    // handle creation of the 'people' map/cache
}

private void onExecuted(@ObservesAsync @Executed @MapName("people") @Processor(Uppercase.class) EntryProcessorEvent event) {
    // intercept 'Uppercase` entry processor execution against 'people', map/cache
}
----

[WARNING]
====

Coherence events fall into two categories: pre- and post-commit events.
All of the events whose name ends  with `"ing"`, such as `Inserting`, `Updating`, `Removing` or `Executing` are pre-commit, which means that they can either modify the data or even veto the operation by throwing an exception, but in  order to do so they must be synchronous to ensure that they are executed on the same thread that is  executing the operation that triggered the event.

That means that you can _observe_ them using asynchronous CDI observers, but if you want to mutate the set of entries that are part of the event payload, or veto the event by throwing an exception, you must use synchronous CDI observer.
====

[#inject-transient]
=== Injecting CDI Beans into Transient Objects

Using CDI to inject Coherence objects into your application classes, and CDI beans into Coherence-managed objects will allow you to support many use cases where dependency injection may be useful, but it doesn't cover an important use case that is somewhat specific to Coherence.

Coherence is a distributed system, and it uses serialization in order to send both the data and the  processing requests from one cluster member (or remote client) to another, as well as to store data, both in memory and on disk.

Processing requests, such as entry processors and aggregators, have to be deserialized on a target cluster member(s) in order to be executed. In some cases, they could benefit from dependency injection in order to avoid service lookups.

Similarly, while the data is stored in a serialized, binary format, it may need to be deserialized into user supplied classes for server-side processing, such as when executing entry processors and aggregators. In this case, data classes can often also benefit from dependency injection (in order to support Domain-Driven Design (DDD), for example).

While these transient objects are not managed by the CDI container, Coherence CDI does support their injection during deserialization, but for performance reasons requires that you explicitly opt-in by implementing `com.oracle.coherence.cdi.Injectable` interface.

[#transient-injectable]
==== Making transient classes `Injectable`

While not technically a true marker interface, `Injectable` can be treated as such for all intents and purposes.
All you need to do is add it to the `implements` clause of your class in order for injection on deserialization to kick in:

[source,java]
----
public class InjectableBean
        implements Injectable, Serializable {

    @Inject
    private Converter<String, String> converter;

    private String text;

    InjectableBean() {
    }

    InjectableBean(String text) {
        this.text = text;
    }

    String getConvertedText() {
        return converter.convert(text);
    }
}
----

Assuming that you have the following `Converter` service implementation in your application, it will be injected into `InjectableBean` during deserialization and the `getConvertedText` method will return the value of the `text` field converted to upper case:

[source,java]
----
@ApplicationScoped
public class ToUpperConverter
        implements Converter<String, String> {
    @Override
    public String convert(String s) {
        return s.toUpperCase();
    }
}
----

NOTE: If your `Injectable` class has `@PostConstruct` callback method, it will be called after the injection.
However, because we have no control over object's lifecycle after that point, `@PreDestroy` callback will *never* be called).

You should note that the above functionality is not dependent on the serialization format and will work with both Java and POF serialization (or any other custom serializer), and for any object that is  deserialized on any Coherence member (or even on a remote client).

While the deserialized transient objects are not true CDI managed beans, being able to inject CDI managed dependencies into them upon deserialization will likely satisfy most dependency injection requirements you will ever have in those application components.
We hope you'll find it useful.


[#custom-filters]
=== Custom FilterBinding Annotations

As already mentioned above, when creating views or subscribing to events, the view or events can be modified using `Filters`.
The exact `Filter` implementation injected will be determined by the view or event observers qualifiers.
Specifically any qualifier annotation that is itself annotated with the `@FilterBinding` annotation.
This should be a familiar pattern to anyone who has worked with CDI interceptors.

For example, if there is an injection point for a view that is a filtered view of an underlying map, but the filter required
is more complex than those provided by the build in qualifiers, or is some custom filter implementation. The steps required are:

* Create a custom annotation class to represent the required `Filter`.
* Create a bean class implementing `com.oracle.coherence.cdi.FilterFactory` annotated with the custom annotation that
will be the factory for producing instances of the custom `Filter`.
* Annotate the view injection point with the custom annotation.

==== Create the Custom Filter Annotation

Creating the filter annotation is simply creating a normal Java annotation class that is annotated with
the `@com.oracle.coherence.cdi.FilterBinding` annotation.

[source,java]
----
@Inherited
@FilterBinding  // <1>
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomFilter {
}
----
<1> The most important part is that this new annotation is annotated with `FilterBinding` so that the Coherence CDI
extensions can recognise that it represents a `Filter`.

==== Create the Custom Filter Factory

Once the custom annotation has been created a `FilterFactory` implementation can be created that will be responsible
for producing instances of the required `Filter`.

[source,java]
----
@ApplicationScoped    // <1>
@CustomFilter         // <2>
static class CustomFilterSupplier
        implements FilterFactory<CustomFilter, Object>
    {
    @Override
    public Filter<Object> create(CustomFilter annotation)
        {
        return new CustomComplexFilter(); // <3>
        }
    }
----
<1> The `CustomFilterSupplier` class has been annotated with `@ApplicationScoped` to make is discoverable by CDI.
<2> The `CustomFilterSupplier` class has been annotated with the new filter binding annotation `@CustomFilter`
so that the Coherence CDI extension can locate it when it needs to create `Filters`.
<3> The `CustomFilterSupplier` implements the `FilterFactory` interface's `create` method where it creates the
custom `Filter` implementation.

==== Annotate the Injection Point

Now there is both a custom annotation, and an annotated `FilterFactory`, the injection point requiring the `Filter`
can be annotated with the new annotation.

[source,java]
----
@Inject
@View
@CustomFilter
private NamedMap<Long, Person> people;
----

As well as views, custom filter binding annotations can also be used for event observers.
For example if there is an event observer method that should only receive events matching the same custom `Filter`
then the method can be annotated with the same custom filter annotation.

[source,java]
----
@CustomFilter
private void onPerson(@Observes @MapName("people") EntryEvent<Long, Person> event) {
----

[#custom-extractor]
=== Custom ExtractorBinding Annotations


[#custom-transformer]
=== Custom MapEventTransformerBinding Annotations
